<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Charlie's Tetris</title>
    <link rel="stylesheet" href="elements.css">
    <style>
        .game-wrapper {
            text-align: center;
        }
        .game-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            font-size: 20px;
            color: #00ff00;
            font-family: "Courier New", monospace;
        }
        .game-info span {
            background: #000;
            padding: 8px 15px;
            border: 2px inset #00ff00;
        }
        canvas {
            background: #111;
        }
        .controls-info {
            color: #00ffff;
            margin-top: 15px;
            font-size: 14px;
        }
        .controls-info kbd {
            background: #333;
            border: 2px outset #666;
            padding: 2px 8px;
            margin: 0 2px;
            font-family: "Courier New", monospace;
        }
        .mobile-controls {
            display: none;
            margin-top: 15px;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .mobile-controls button {
            width: 60px;
            height: 60px;
            font-size: 24px;
            background: linear-gradient(to bottom, #00ff00, #00cc00);
            color: #000;
            border: 3px outset #fff;
            font-weight: bold;
            cursor: pointer;
        }
        .mobile-controls button:active {
            border: 3px inset #fff;
        }
        @media (max-width: 600px) {
            .mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>

<div class="wrapper">
    <h1 class="neon">üéÆ CHARLIE'S TETRIS üéÆ</h1>

    <marquee behavior="alternate" scrollamount="4">
        ‚≠ê STACK 'EM UP ‚≠ê CLEAR THOSE LINES ‚≠ê BE THE TETRIS CHAMPION ‚≠ê
    </marquee>

    <div class="game-wrapper">
        <div class="game-info">
            <span>Score: <strong id="score">0</strong></span>
            <span>Lines: <strong id="lines">0</strong></span>
            <span>Level: <strong id="level">1</strong></span>
        </div>

        <canvas id="tetris" width="300" height="600"></canvas>

        <div class="controls-info">
            <p><kbd>&larr;</kbd> <kbd>&rarr;</kbd> Move | <kbd>&uarr;</kbd> Rotate | <kbd>&darr;</kbd> Soft Drop | <kbd>Space</kbd> Hard Drop</p>
            <p><kbd>P</kbd> Pause | <kbd>R</kbd> Restart</p>
        </div>

        <div class="mobile-controls">
            <button onclick="moveLeft()">&larr;</button>
            <button onclick="rotatePiece()">&#8635;</button>
            <button onclick="moveRight()">&rarr;</button>
            <button onclick="softDrop()">&darr;</button>
            <button onclick="hardDrop()">&#9660;</button>
        </div>

        <div style="margin-top: 20px;">
            <button class="button" onclick="startGame()">‚ñ∂ Start Game</button>
            <button class="button" onclick="togglePause()">‚è∏ Pause</button>
        </div>
    </div>

    <div style="text-align: center; margin-top: 30px;">
        <a class="button" href="index.html">üè† Back to Homepage</a>
    </div>
</div>

<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const COLS = 10;
const ROWS = 20;
const BLOCK = 30;
const COLORS = [
    null,
    '#00ffff', // I - cyan
    '#0000ff', // J - blue
    '#ff8800', // L - orange
    '#ffff00', // O - yellow
    '#00ff00', // S - green
    '#9900ff', // T - purple
    '#ff0000'  // Z - red
];

const PIECES = [
    [[1,1,1,1]],                    // I
    [[2,0,0],[2,2,2]],              // J
    [[0,0,3],[3,3,3]],              // L
    [[4,4],[4,4]],                  // O
    [[0,5,5],[5,5,0]],              // S
    [[0,6,0],[6,6,6]],              // T
    [[7,7,0],[0,7,7]]               // Z
];

let board, piece, pieceRow, pieceCol, score, linesCleared, level;
let gameInterval, paused, gameOver, gameStarted;

function createBoard() {
    return Array.from({length: ROWS}, () => Array(COLS).fill(0));
}

function newPiece() {
    const idx = Math.floor(Math.random() * PIECES.length);
    piece = PIECES[idx].map(r => [...r]);
    pieceRow = 0;
    pieceCol = Math.floor((COLS - piece[0].length) / 2);
    if (collides(piece, pieceRow, pieceCol)) {
        gameOver = true;
        clearInterval(gameInterval);
        gameInterval = null;
    }
}

function collides(p, row, col) {
    for (let r = 0; r < p.length; r++) {
        for (let c = 0; c < p[r].length; c++) {
            if (p[r][c]) {
                const nr = row + r;
                const nc = col + c;
                if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return true;
                if (board[nr][nc]) return true;
            }
        }
    }
    return false;
}

function merge() {
    for (let r = 0; r < piece.length; r++) {
        for (let c = 0; c < piece[r].length; c++) {
            if (piece[r][c]) {
                board[pieceRow + r][pieceCol + c] = piece[r][c];
            }
        }
    }
}

function clearLines() {
    let cleared = 0;
    for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
            board.splice(r, 1);
            board.unshift(Array(COLS).fill(0));
            cleared++;
            r++;
        }
    }
    if (cleared > 0) {
        const points = [0, 100, 300, 500, 800];
        score += (points[cleared] || 800) * level;
        linesCleared += cleared;
        level = Math.floor(linesCleared / 10) + 1;
        updateInfo();
        updateSpeed();
    }
}

function updateInfo() {
    document.getElementById('score').textContent = score;
    document.getElementById('lines').textContent = linesCleared;
    document.getElementById('level').textContent = level;
}

function updateSpeed() {
    if (gameInterval) {
        clearInterval(gameInterval);
        const speed = Math.max(100, 800 - (level - 1) * 70);
        gameInterval = setInterval(tick, speed);
    }
}

function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw grid lines
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 0.5;
    for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * BLOCK);
        ctx.lineTo(COLS * BLOCK, r * BLOCK);
        ctx.stroke();
    }
    for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(c * BLOCK, 0);
        ctx.lineTo(c * BLOCK, ROWS * BLOCK);
        ctx.stroke();
    }

    // Draw board
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (board[r][c]) {
                drawBlock(c, r, COLORS[board[r][c]]);
            }
        }
    }

    // Draw current piece
    if (piece && !gameOver) {
        for (let r = 0; r < piece.length; r++) {
            for (let c = 0; c < piece[r].length; c++) {
                if (piece[r][c]) {
                    drawBlock(pieceCol + c, pieceRow + r, COLORS[piece[r][c]]);
                }
            }
        }
    }

    // Game over overlay
    if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ff00ff';
        ctx.font = 'bold 30px "Comic Sans MS"';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillStyle = '#00ffff';
        ctx.font = '18px "Comic Sans MS"';
        ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 + 15);
        ctx.fillText('Press R to restart', canvas.width / 2, canvas.height / 2 + 45);
    }

    if (!gameStarted) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 24px "Comic Sans MS"';
        ctx.textAlign = 'center';
        ctx.fillText('CHARLIE\'S TETRIS', canvas.width / 2, canvas.height / 2 - 20);
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Comic Sans MS"';
        ctx.fillText('Click Start Game!', canvas.width / 2, canvas.height / 2 + 15);
    }
}

function drawBlock(x, y, color) {
    const px = x * BLOCK;
    const py = y * BLOCK;
    ctx.fillStyle = color;
    ctx.fillRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(px + 1, py + 1, BLOCK - 2, 4);
    ctx.fillRect(px + 1, py + 1, 4, BLOCK - 2);
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(px + BLOCK - 5, py + 1, 4, BLOCK - 2);
    ctx.fillRect(px + 1, py + BLOCK - 5, BLOCK - 2, 4);
}

function tick() {
    if (paused || gameOver || !gameStarted) return;
    if (!collides(piece, pieceRow + 1, pieceCol)) {
        pieceRow++;
    } else {
        merge();
        clearLines();
        newPiece();
    }
    draw();
}

function moveLeft() {
    if (paused || gameOver || !gameStarted) return;
    if (!collides(piece, pieceRow, pieceCol - 1)) {
        pieceCol--;
        draw();
    }
}

function moveRight() {
    if (paused || gameOver || !gameStarted) return;
    if (!collides(piece, pieceRow, pieceCol + 1)) {
        pieceCol++;
        draw();
    }
}

function softDrop() {
    if (paused || gameOver || !gameStarted) return;
    if (!collides(piece, pieceRow + 1, pieceCol)) {
        pieceRow++;
        score += 1;
        updateInfo();
        draw();
    }
}

function hardDrop() {
    if (paused || gameOver || !gameStarted) return;
    while (!collides(piece, pieceRow + 1, pieceCol)) {
        pieceRow++;
        score += 2;
    }
    merge();
    clearLines();
    updateInfo();
    newPiece();
    draw();
}

function rotatePiece() {
    if (paused || gameOver || !gameStarted) return;
    const rotated = piece[0].map((_, i) => piece.map(row => row[i]).reverse());
    if (!collides(rotated, pieceRow, pieceCol)) {
        piece = rotated;
    } else if (!collides(rotated, pieceRow, pieceCol - 1)) {
        pieceCol--;
        piece = rotated;
    } else if (!collides(rotated, pieceRow, pieceCol + 1)) {
        pieceCol++;
        piece = rotated;
    }
    draw();
}

function togglePause() {
    if (!gameStarted || gameOver) return;
    paused = !paused;
    if (paused) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 28px "Comic Sans MS"';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
    } else {
        draw();
    }
}

function startGame() {
    board = createBoard();
    score = 0;
    linesCleared = 0;
    level = 1;
    paused = false;
    gameOver = false;
    gameStarted = true;
    updateInfo();
    if (gameInterval) clearInterval(gameInterval);
    newPiece();
    gameInterval = setInterval(tick, 800);
    draw();
}

// Keyboard controls
document.addEventListener('keydown', function(e) {
    if (e.key === 'r' || e.key === 'R') {
        startGame();
        return;
    }
    if (e.key === 'p' || e.key === 'P') {
        togglePause();
        return;
    }
    if (!gameStarted || paused || gameOver) return;
    switch(e.key) {
        case 'ArrowLeft':
            e.preventDefault();
            moveLeft();
            break;
        case 'ArrowRight':
            e.preventDefault();
            moveRight();
            break;
        case 'ArrowDown':
            e.preventDefault();
            softDrop();
            break;
        case 'ArrowUp':
            e.preventDefault();
            rotatePiece();
            break;
        case ' ':
            e.preventDefault();
            hardDrop();
            break;
    }
});

// Initial draw
board = createBoard();
score = 0;
linesCleared = 0;
level = 1;
paused = false;
gameOver = false;
gameStarted = false;
draw();
</script>

</body>
</html>
